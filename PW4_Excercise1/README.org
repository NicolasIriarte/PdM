* English
** Point 1
Implement the helper functions needed to use non-blocking delays in a =main.c= source file with its corresponding =main.h= header file.

The prototypes of the following functions should be located in =main.h=
and the statements

#+name: Necessary code
#+header: :main no
#+header: :cmdline
#+begin_src C :noweb strip-export
  // What library must be included for this to compile?
  typedef uint32_t tick_t;

  // What library must be included for this to compile?
  typedef bool bool_t;
  typedef struct {
    tick_t startTime;
    tick_t duration;
    bool_t running;
  } delay_t;

  void delayInit(delay_t *delay, tick_t duration);
  bool_t delayRead(delay_t *delay);
  void delayWrite(delay_t *delay, tick_t duration);
#+end_src

In =main.c= you must place the implementation of all the functions:
Implementation considerations:

1. =delayInit= should load the value of the delay duration into the structure, in the corresponding field. It should not start the delay count. You must initialize the running flag to =false=.

2. =delayRead= should check the status of the running flag.
   - =false=, take timestamp and change running to =true=
   - =true=, do the calculation to know if the delay time has expired or not:

   =current timestamp - start timestamp is greater than or equal to delay duration=?

   and return a boolean value that indicates if the time is up or not.
   - When the time is up, the running flag must be changed to =false=.

3. =delayWrite= should allow changing the length of an existing delay.


** Point 2
Implement a program that uses non-blocking delays and makes the three leds of the NUCLEO-F429ZI board blink periodically and independently as follows:

- LED1: 100ms.
- LED2: 500ms.
- LED3: 1000ms.

* Español
** Punto 1:
Crear un nuevo proyecto como copia del proyecto realizado para la práctica 3.

Implementar una =MEF= anti-rebote que permita leer el estado del pulsador de la
placa =NUCLEO-F429ZI= y generar acciones o eventos ante un flanco descendente o
ascendente, de acuerdo al siguiente diagrama:

[[file:assets/FSM.png]]

El estado inicial de la MEF debe ser BUTTON_UP.

Implementar dentro de main.c, las funciones:

#+name:
#+begin_src C
  void debounceFSM_init();		// debe cargar el estado inicial
  void debounceFSM_update();	// debe leer las entradas, resolver la lógica de
                              // transición de estados y actualizar las salidas

  void buttonPressed();			// debe invertir el estado del LED1
  void buttonReleased();		// debe invertir el estado del LED3

#+end_src

El tiempo de anti-rebote debe ser de *40 ms* con un retardo *no* bloqueante como los implementados en la práctica 3.

La función =debounceFSM_update()= debe llamarse periódicamente.

#+begin_src C
  typedef enum {
    BUTTON_UP,
    BUTTON_FALLING,
    BUTTON_DOWN,
    BUTTON_RAISING,
  } debounceState_t;
#+end_src

